# API на Next.JS

Всім привіт, вітаю вас на експрес курсі Next.JS для початківців. Мене звати Віталій Рубан, я працюю в компанії Ітера і сьогодні у нас тема - API на Next.JS

Я розповім про

- Навіщо нам API
- Раутинг з API
- Параметри запиту
- Відповідь з API
- Та про деякі нюанси використання API в Next.JS

Починаємо

## Навіщо нам API

Отже навіщо нам взагалі потрібен API, якщо серверні компоненти і так виконуються на сервері. Відповідь на це дуже проста - API потрібен для зміни цих даних з клієнту, або довантаження якихось даних пізніше, також з клієнту.

При цьому ви використовуєте ту саму мову - JavaScript або TypeScript, використовуєте той самий код (наприклад валідації) і працюєте в одному репозиторії що суттєво спрощує нашу роботу.

## Раутинг з API

Тепер давайте коротко поговоримо про принципи побудови роутінгу для API в Next.JS. На щастя, принципи майже такі самі як і з роутінгом для сторінок. Роутинг грунтується на файловій системі, конвенції для тек теж такі самі. Якщо вам потрібен роут виду /api/user/userId де userId динамічна частина роуту - ви створюєте теку апі, в теці api створюється тека user, а в теці user створюється тека userId в квадратних дужках. Якщо ця частина звучить для вас не дуже знайомо - рекомендую подивитися інший відео урок про routing для сторінок, посилання у вас зараз на екрані. 

Отже все дуже схоже, але, звісно є відмінності. 

По-перше назва файла. Якщо сторінки ми називаємо page.js/jsx то файли в яких буде наші API називаються route.ts/js. Тобто будь-який файл API має обов'язково називатися route.ts щоб Next.JS міг включити його в роутинг.

По-друге, кожен файл route.ts має експортувати функції або функцію, назва з якою збігається з назвою HTTP метода, причому назва цього методу має бути обов'язково з великої літери. Якщо вам потрібно обробити GET запит, експортуємо функцію GET, якщо і GET і POST - експортуємо дві функції які так і будуть називатися - GET і POST

Важливий момент - ви не можете тримати файли page.ts та route.ts поруч, тому що Next не зможе вирішити що ж треба робити  - чи то сторінку відмальовувати чи API запит оброблювати. Тому шляхи мають бути індивідуальні. Я, зазвичай, для обробників ствоюю окрему теку - API і це вирішує всі мої проблеми.

# Приклад

Давайте поглянемо на найпростіший приклад реалізації обробника GET запиту

Як бачите, це звичайна функція, що називається GET яка повертає результат виконання методу json в який я передав звичайний собі об'єкт. Як бачите - зовсім не складно. Зупиніть це відео та спробуйте реалізувати цей функціонал самотужки. Нагадую, що файл має називатися route.js або ts, і не лежати поруч із page. А для того щоб перевірити себе - просто відкрийте браузер за адресою вашого роуту - ви маєте побачити цей об'єкт прямо на вашому екрані. 

Окрім GET запитів, NextJS також підтримує POST, PUT, PATH, DELETE, HEAD, та OPTIONS

Ще раз хочу наголосити, що функції мають бути обов'язково названі великими літерами. 


## Params

Тепер давайте розглянемо більш складні та корисні приклади і почнемо ми з параметрів запиту. Параметри запиту діляться на три категорії - парамс, які ми отримуємо з URL, коли створюємо динамічний (в квадратних дужках) роут, квері - частина URL що йде після знаку питання та саме тіло запиту. 

Почнемо з отримання парамсів. Уявіть собі що наш шлях виглядає як api/user/[userId] де userId - динамічна частину роутингу. Як отримати цей userId? Дуже просто - достатньо звернутися до другого аргументу нашої функції обробника, так як ви бачите у себе на екрані. Другий аргумент містить властивість params - це словник де будуть лежати всі ваші динамічні сегменти. 

Для отримання квері параметрів, ми маємо звернутися вже до першого аргументу функції обробника. Це об'єкт який представляє собою дані отримані під час запиту. Використайте властивість `nextUrl` для отримання об'єкту searchParams. Цей об'єкт і буде мати всі необхідні вам квері параметри. 

А для отримання тіла запиту, наприклад якщо це POST запит, достатньо звернутися до функції json об'єкту request. Пам'ятайте, що метод json повертає проміс, то ж вам буде потрібно використати ключове await а також позначити функцію як асинхронну за допомогою ключового async. 

До-речі, оскільки наші функції обробники запитів можуть бути асинхронними - це дозволяє з них робити інші асинхронні дії - наприклад запити на інші ендпоінти або до бази даних.

Як бачите - робота з вхідними даними досить проста. Поставте це відео на паузу і спробуйте реалізувати свій обробник GET запиту який поверне вам у відповідь userId з params та lang з квері параметрів.

## Тіло запита

## Відповідь

Тепер давайте розберемо як відповідати на запит. Найпростіший варіант відповіді ви вже бачили0 - це також
