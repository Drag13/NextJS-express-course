# API на Next.JS

Всім привіт, вітаю вас на експрес курсі Next.JS для початківців. Мене звати Віталій Рубан, я працюю в компанії Ітера і сьогодні у нас тема - API на Next.JS

Я розповім про

- Навіщо нам API
- Як будується раутинг для API
- Як отримати параметри запиту
- Як зробити відповідь
- Та про деякі нюанси використання API в Next.JS

Але перед тим як ми почнемо - хочу сказати що це відео благодійне, і знято на користь одного з підрозділів 112 Бригади ТРО яка приймала участь в захисті Київського неба. Якщо вам це відео сподобається - будь-ласка прийміть участь у зборі на генератор та сонячну панель для них. Кожні 50 гривень приймають участь в розіграші розписаної гільзи 30 калібру, а найбільший донат отримає книжку Грокаємо алгоритми. Посилання у вас на екрані. Також буду вдячний за лайк, підписку та поширення.

Починаємо

## Навіщо нам API

Отже навіщо нам взагалі потрібен API, якщо серверні компоненти і так виконуються на сервері. Відповідь на це дуже проста - API потрібен для зміни цих даних з клієнту, або довантаження якихось даних пізніше, також з клієнту.

При цьому ви використовуєте ту саму мову - JavaScript або TypeScript, використовуєте той самий код (наприклад валідації) і працюєте в одному репозиторії що суттєво спрощує нашу роботу.

## Раутинг з API

Тепер давайте коротко поговоримо про принципи побудови роутінгу для API в Next.JS. На щастя, принципи майже такі самі як і з роутінгом для сторінок. Роутинг грунтується на файловій системі, а конвенції для назви теж такі самі. Якщо вам потрібен роут виду /api/user/userId де userId динамічна частина роуту - ви створюєте теку апі, в теці api створюється тека user, а в теці user створюється тека userId в квадратних дужках. Якщо ця частина звучить для вас не дуже знайомо - рекомендую подивитися інший відео урок про routing для сторінок, посилання у вас зараз на екрані.

Отже все дуже схоже, але, звісно є відмінності.

По-перше назва файла. Якщо сторінки ми називаємо page.js/jsx то файли в яких буде наші API називаються route.ts/js. Тобто будь-який файл API має обов'язково називатися route.ts щоб Next.JS міг включити його в роутинг.

По-друге, кожен файл route.ts має експортувати функції або функцію, назва яких збігається з назвою HTTP метода, причому назва цього методу має бути обов'язково великими літерами. Якщо вам потрібно обробити GET запит, експортуємо функцію GET, якщо і GET і POST - експортуємо дві функції які так і будуть називатися - GET і POST

Важливий момент - ви не можете тримати файли page.ts та route.ts поруч, тому що Next не зможе вирішити що ж треба робити - чи то сторінку відмальовувати чи API запит оброблювати. Тому шляхи мають бути індивідуальні. Я, зазвичай, для обробників ствоюю окрему теку - API і це вирішує всі мої проблеми.

# Приклад

Давайте поглянемо на найпростіший приклад реалізації обробника GET запиту

Як бачите, це звичайна функція, що називається GET яка повертає результат виконання методу json в який я передав звичайний собі об'єкт. Як бачите - зовсім не складно. Зупиніть це відео та спробуйте реалізувати цей функціонал самотужки. Нагадую, що файл має називатися route.js або ts, і не лежати поруч із page. А для того щоб перевірити себе - просто відкрийте браузер за адресою вашого роуту - ви маєте побачити цей об'єкт прямо на вашому екрані.

Окрім GET запитів, NextJS також підтримує POST, PUT, PATH, DELETE, HEAD, та OPTIONS

Ще раз хочу наголосити, що функції мають бути обов'язково названі великими літерами.

## Params

Тепер давайте розглянемо більш складні та корисні приклади і почнемо ми з параметрів запиту. Параметри запиту діляться на декілька категорій - парамс, які ми отримуємо з URL, коли створюємо динамічний (в квадратних дужках) роут, квері - частина URL що йде після знаку питання та саме тіло запиту.

Почнемо з отримання парамсів. Уявіть собі що наш шлях виглядає як api/user/[userId] де userId - динамічна частину роутингу. Як отримати цей userId? Дуже просто - достатньо звернутися до другого аргументу нашої функції обробника, так як ви бачите у себе на екрані. Другий аргумент містить властивість params - це словник де будуть лежати всі ваші динамічні сегменти.

Для отримання квері параметрів, ми маємо звернутися вже до першого аргументу функції обробника. Це об'єкт який представляє собою дані отримані під час запиту. Використайте властивість `nextUrl` для отримання об'єкту searchParams. Цей об'єкт і буде мати всі необхідні вам квері параметри.

А для отримання тіла запиту, наприклад якщо це POST запит, достатньо звернутися до функції json об'єкту request який Next.JS передає нам першим аргументом автоматично. Пам'ятайте, що метод json повертає проміс, то ж вам буде потрібно використати ключове await а також позначити функцію як асинхронну за допомогою ключового async.

До-речі, оскільки наші функції обробники запитів можуть бути асинхронними - це дозволяє з них робити інші асинхронні дії - наприклад запити на інші ендпоінти або до бази даних.

Окрім тіла запиту, парамсів та квері вам також знадобляться кукі та заголовки.

Щоб отримати доступ до куків вам потрібно використати функцію cookies яка імпортується з пакету `next/headers` - зверніть увагу на перший рядок прикладу на вашому екрані. Ви також можете прочитати кукі використовуючи об'єкт cookies з request, але з ними є халепа. Ви зможете лише прочитати кукі, а от встановити їх не вийде - Next.JS мовчки відмовляється це робити.

Для того щоб прочитати HTTP заголовки запиту, наприклад дізнатися user-agent користувача або аутентифікаційний заголовок, ви можете використати властивість headers об'єкту реквест

Окрім очікуваних властивостей, Next.JS також намагається надати вам доступ до додаткових параметрів, таких як IP адреса користувача та місце його розташування. Але це працює з коробки лише якщо ви деплоїтесь на Vercel. З іншими провайдерами цей функціонал вимагає доналаштувань

Як бачите - робота з вхідними параметрами досить проста. Поставте це відео на паузу і спробуйте реалізувати свій обробник GET запиту який поверне вам у відповідь userId з params та lang з квері параметрів.

## Відповідь

Тепер давайте розберемо як відповідати на запит. Найпростіший варіант відповіді ви вже бачили - достатньо викликати статичний метод json на класі Response і передати туди бажаний об'єкт. Також ми можемо повернути і звичайний текст (що може бути корисно якщо нам потрібно відправити, наприклад, дані у СVS форматі)

Ми також можемо вказати статус код відповіді - наприклад 400ий код bad request або 401 для unauthorized. Для цього потрібно передати об'єкт конфігурації відповіді в якості другого аргументу метода Response.json. Там же ви можете встановити додаткові HTTP заголовки за допомогою об'єкту headers. Приклад у вас на екрані.

Окрім звичайних відповідей Next.js дозволяє також зробити перенаправлення за допомогою методу redirect. В цьому випадку браузер зробить повторний запит за вказаною адресою. Важливо, що посилення яке ви вказуєте має бути абсолютним, відносні посилання не допускаються.

Окрім перенаправлення ви можете також зробити rewrite - але про це ми поговоримо іншим разом.

Cпробуйте створити декілька ендпонтів - один що поверне вам текст hello world, інший який буде повертати статус код 400, і третій який перенаправить вас на один з попередніх.

Тепер давайте поговоримо про важливі нюанси.

По-перше не робіть помилку і не звертайтесь до ваших API ендпоінтів з-під серверних компонентів. Серверні компоненти виконують лише на сервері і вам не потрібно робити мереживий виклик - просто виконайте код що повертає потрібні вам дані, цим ви зекономите собі час та ресурси серверу

По-друге - результати GET запиту без параметрів, куків та хедеоів кешуються, тому не дивуйтеся що список, який ви щойно оновили за допомогою POST запиту залишився не змінним, це через кеш. Але тема кешування в Next.JS досить велика, її ми розберемо іншим разом.

І, по-третє, не забувайте що назви методів мають складатися виключно з великих літер, інакше ваш обробник не буде знайдено. Спробуйте самі щоб переконатися.

Тепер давайте підведемо підсумки.

- За допомогою Next.JS ви можете побудувати власний API
- Методи API виконуються на сервері і можуть бути асинхронними
- Next.JS підтримує GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD методи.
- Для роботи з параметром запиту ми використовуємо об'єкт NextRequest який передається першим аргументом, та об'єкт що містить params - переданий в якості другого аргументу в функцію обробник роуту.
- Для відповіді на запит ми використовуємо об'єкт Response який може повернути нам JSON, текст а також зробити redirect чи встановити якісь HTTP заголовки
- Якщо нам потрібно встановити якісь кукі - ми використовуємо функцію кукіс з пакету next/headers

Ще раз нагадую що це благодійне відео для підтримки підрозділу з 112 батальйону ТРО - якщо у вас є можливість, будь-ласка долучайтеся до збору та приймате участь у розіграші. Розіграш проводиться через монобанк і якщо ви виграєте ви отримаєте відповідно сповіщення.

Всім дякую хто додивився - якщо вам сподобалося це відео - підписуйтесь на наш ютуб та телеграм канали. Бережіть себе та допомагайте ЗСУ. 
